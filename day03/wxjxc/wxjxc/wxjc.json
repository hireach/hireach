{"title": "微信小程序开发需要注意的一些规范 ", "author": "Rolan", "pub_time": "2019-5-5 00:42", "content": "出现 JavaScript 异常可能导致小程序的交互无法进行下去，我们应当追求零异常，保证小程序的高鲁棒性和高可用性，相信这一点一般情况下都不会出现，需要注意的是代码测试中多场景的试错。2.合理控制图片的大小图片太大会增加下载时间和内存的消耗，应根据显示区域大小合理控制图片大小。 一般情况下图片较大的，我们应该都会选择直接放在服务器上，直接拿到地址，但是官方说这样读取的图片： 存在网络图片资源未开启 HTTP 缓存控制 ,这是个什么意思，我也未完全弄懂。3.小程序所有请求应响应正常请求失败可能导致小程序的交互无法进行下去，应当保证所有请求都能成功。然而，请求成功只是第一步，还可能存在的问题就是请求的耗时太长、存在短时间内发起太多的请求这样的情况，一方面是后台人员的接口写的烂，一方面就是需求使然（技术半吊子，还想安全的产品经理会有这种让你去指定地方请求的情况），比如在阿里云OSS存储的一些json数据。。。。4.避免setData的数据过大且避免setData的调用过于频繁。由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间. setData接口的调用涉及逻辑层与渲染层间的线程通过，通信过于频繁可能导致处理队列阻塞，界面渲染不及时而导致卡顿，应避免无用的频繁调用.5.避免将未绑定在 WXML 的变量传入 setDatasetData操作会引起框架处理一些渲染界面相关的工作，一个未绑定的变量意味着与界面渲染无关，传入setData会造成不必要的性能消耗。 这一条我想是很多开发人员在初次接触小程序开发的时候都会犯的一个错误吧。因为刚开始的时候由于这种setData的语法，让我们忘了还有全局变量的使用，于是会经常出现使用Page中定义的data做中间过渡。6.wxss 覆盖率较高，较少或没有引入未被使用的样式我们应该按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度。 这个也是比较常见的一种不规范，写了很多CSS样式，很多不用的就留来了代码里面，越来越多，所以在编写代码过程中，尽量去对每一行代码（特别是自己写的）了如指掌。7.避免首屏时间太长的情况首屏时间是指用户开始看到第一屏的内容的时间，首屏时间太长会导致用户长时间看到的都是白屏，会一直等待有意义的内容展示出来。出现这一情况，应仔细检查这个过程都有哪个操作，一般来说，可能是请求数据的时间太长，或者是一次渲染的数据太大导致渲染时间太长。这些东西是我感觉比较常见且容易修改的，其它还存在一些规范，不妨打开微信开发者工具，点击 Audits ,对你写的代码进行一个测试，测试结果会让你很好的处理自己的代码。That's really cool!"}
{"title": "微信小程序怎么使用icon ", "author": "Rolan", "pub_time": "2019-4-30 00:21", "content": "小程序怎么使用icon第一步 下载icon我选择的图标库是阿里图标官网， 加入购物车第二步 转换ttf因为小程序的wxss文件的font-face的url不接受http地址作为参数,但可以接受base64,因此需将字体文件下载后,转换为base64，然后引用进入https://transfonter.org/平台点击Add fonts，添加iconfont.ttf勾选Base64 encode点击 convert 完成转换按照上图1,2,3的步骤 转换完成， 点击Download第三步 在微信小程序中使用icon解压 第二步中的文件夹找到stylesheet.css 文件打开第一步中压缩包的iconfont.css，把里面圈红的部分（即fontface部分我们不需要啦）复制到stylesheet.css修改后的stylesheet.css修改stylesheet.css的文件后缀为wxss，即stylesheet.wxss把stylesheet.wxss放进微信小程序的公共文件里面，然后把整个文件import到页面的样式表里在wxml页面引入使用完结"}
{"title": "微信小程序生命周期与性能指标 ", "author": "Rolan", "pub_time": "2019-5-5 00:47", "content": "本文将介绍微信小程序整个App的生命周期、单个页面的生命周期和组件的生命周期，并研究了这三个元素生命周期的关系，这在学习和开发过程中对理解小程序运行机制有重要意义。最终，由生命周期整理出小程序的关键指标，仅供参考。App的生命周期在app.js中有其生命周期相关的三个方法：onLaunch、onShow和onHide。首先是onLaunch，这是整个小程序的第一个生命周期回调函数，在小程序初始化完成后调用。接着，小程序将触发onShow事件，如果小程序从后台切回前台后也会触发该事件。最后，是小程序切到后台的事件onHide。Page的生命周期在每个页面注册函数Page()的参数中，有生命周期的方法：onLoad、onShow、onReady、onHide、onUnload。页面触发的第一个生命周期回调是onLoad，在页面加载的时候触发，其参数是页面的query参数，一个页面只有一次；接着是onShow，监听页面的显示，与onLoad不同，如果页面被隐藏后再次显示（例如：进入下一页后返回），也会触发该生命周期；触发onShow之后，逻辑层会向渲染层发送初始化数据，渲染层完成第一次渲染之后，会通知逻辑层触发onReady生命周期，一个页面只有一次；onHide是页面隐藏但未卸载的时候触发的，如 wx.navigateTo 或底部tab切换到其他页面，小程序切入后台等。onUnload是页面卸载时触发，如wx.redirectTo或wx.navigateBack到其他页面时。Component的生命周期组件最重要的生命周期是created、attached、detached ，包含一个组件实例生命流程的最主要时间点。首先，当组件实例刚被创建时， created生命周期被触发。此时，还不能调用setData 。 通常情况下，这个生命周期只应该用于给组件this添加一些自定义属性字段。接着，在组件完全初始化完毕并且进入页面节点树后， attached生命周期被触发。此时， this.data 已被初始化为组件的当前值，绝大多数初始化工作可以在这个时机进行。在组件离开页面节点树后， detached生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。此外，组件生命周期还有ready和move生命周期，分别在视图层布局完成和组件实例被移动到节点树另一个位置时执行。整体周期现在我们知道了App、Page、和Component分别的生命周期顺序，那么他们之间的生命周期顺序又是如何？通过开发一个简单的demo，观察运行结果，可以得到如下结论：打开页面的情况首先，前一个页面隐藏，在加载下一个页面之前，需要先初始化新页面的组件。页面首次渲染之后，会触发组件的ready，最后触发的是页面的onReady，如下图：从PageA打开pageB时的生命周期顺序离开页面的情况离开当前页面时，首先触发当前页面的卸载onUnload，接着是组件离开节点树的detached。最后显示之前的页面，触发onShow。如下图：从PageB返回到PageA的生命周期顺序打开App的情况App、Page与Component生命周期运行顺序，先从App加载然后再加载Page，在加载Page之前会先初始化该页面所用的所有组件，之后才触发页面的onLoad生命周期，如下图：打开App时的生命周期顺序切换到后台切换到后台时，小程序和页面并没有卸载，只会触发隐藏。先触发页面的onHide，接着是App的onHide。如下图：切换到后台时的生命周期顺序切换到前台切换到后台时，小程序会先触发onShow，之后才是页面的onShow。如下图：切换到前台时的生命周期顺序关键性能指标了解了小程序各个阶段的生命周期，我们可以制定出关键节点的性能指标，整理如下表：参考文档官方文档 Page：developers.weixin.qq.com/miniprogram…官方文档 App：developers.weixin.qq.com/miniprogram…官方文档 页面生命周期：developers.weixin.qq.com/miniprogram…官方文档 组件生命周期：developers.weixin.qq.com/miniprogram…"}
{"title": "手把手教你写一个微信小程序日历组件 ", "author": "Rolan", "pub_time": "2019-5-6 00:24", "content": "今天我们一起写一个微信小程序日历组件\r\n\r\n微信小程序日历组件\r\ngithub.com/749264345/w…\r\n\r\n好，我们先看一下要实现的模样，如下图\r\n\r\n\r\n由以上截图我们可以看到\r\n\r\n1.日历可以通过按钮【切换展示效果】改变日历的呈现效果，上图是平铺模式，下图是收起滚动模式。\r\n2.通过点击具体的日期可以在页面上显示当前选中的具体日期。\r\n3.点击【今天】快速回到当日视图。\r\n4.点击【◀】和【▶】切换月份。\r\n上面的四点也是基本的交互需求，我们马上开始。\r\n首先，我们先结构后样式，做出最基本的界面结构\r\n这边我们把整体结构分成上中下，操作显示区，星期显示区，日期显示区。\r\n\r\n<view class='calendar'>\r\n    <!--显示当前年月日-->\r\n    <view class='calendar-title'>\r\n        <view class='item ctrl' bindtap='lastMonth'>{{lastMonth}}</view>\r\n        <view class='item title'>{{title}}</view>\r\n        <view class='item ctrl' bindtap='nextMonth'>{{nextMonth}}</view>\r\n        <view class='item ctrl today' bindtap='today'>今天</view>\r\n    </view>\r\n\r\n    <!--星期-->\r\n    <view class='calendar-week'>\r\n        <view class='item'>{{item}}</view>\r\n    </view>\r\n\r\n    <!--日期-->\r\n    <view class='calendar-container'>\r\n        <!--上个月占位格子-->\r\n        <view class='grid gray'>{{item}}</view>\r\n\r\n        <!--当月格子-->\r\n        <view class='grid'>\r\n            <view class=\"wrap\">{{item.date}}</view>\r\n        </view>\r\n\r\n        <!--下个月占位格子-->\r\n        <view class='grid gray'>{{item}}</view>\r\n    </view>\r\n</view>\r\n复制代码这是我们基本的日历结构，机智的小伙伴已经从布局中知道我们实现的大致逻辑了，是的，我们先获取当月有多少天，上月和下月有多少天，这样我们的日历就出来了。好，慢慢来，下面我们详细说，我们先写上基本的样式。\r\n.calendar {\r\n    width: 100%;\r\n    text-align: center;\r\n    font-size: 30rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n/* 标题 */\r\n.calendar-title {\r\n    line-height: 70rpx;\r\n    font-size: 30rpx;\r\n    text-align: left;\r\n    padding: 0 20rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.calendar-title .ctrl {\r\n    display: inline-block;\r\n    padding: 0 20rpx;\r\n    background: #f5f5f5;\r\n    border-radius: 10rpx;\r\n}\r\n\r\n.calendar-title .item {\r\n    display: inline-block;\r\n    vertical-align: middle;\r\n    line-height: 50rpx;\r\n}\r\n\r\n.calendar-title .title {\r\n    min-width: 300rpx;\r\n    text-align: center;\r\n}\r\n\r\n.calendar-title .today {\r\n    float: right;\r\n    margin-top: 10rpx;\r\n}\r\n\r\n/* 星期 */\r\n.calendar-week {\r\n    display: flex;\r\n    text-align: center;\r\n    padding: 20rpx 10rpx;\r\n    box-sizing: border-box;\r\n    border-top: 1rpx solid #e0e0e0;\r\n    border-bottom: 1rpx solid #e0e0e0;\r\n    background: #f5f5f5;\r\n}\r\n\r\n.calendar-week .item {\r\n    flex: 1;\r\n}\r\n\r\n/* 日期 */\r\n.calendar-container {\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    padding: 20rpx 10rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.calendar-container .grid {\r\n    display: inline-block;\r\n    width: 14.28571428571429%;\r\n    line-height: 70rpx;\r\n    position: relative;\r\n    z-index: 1;\r\n}\r\n\r\n.calendar-container .grid.gray {\r\n    color: #ccc;\r\n}\r\n\r\n.calendar-container .grid .wrap.select {\r\n    background: rgb(49, 120, 228);\r\n    border-radius: 10rpx;\r\n    color: #fff;\r\n    width: 80%;\r\n    margin: 0 auto;\r\n}\r\n复制代码以上我们基本试下了日历的界面，下面我们来实现星期和日期的展示。\r\n好，我们先显示星期，我们先在组件中定义一个数组，用来遍历显示星期的标题；\r\nComponent({\r\n    properties: {\r\n        //星期数组\r\n        weekText: {\r\n            type: Array,\r\n            value: ['周日', '周一', '周二', '周三', '周四', '周五', '周六']\r\n        }\r\n    },\r\n    ...\r\n})\r\n复制代码我们将星期的标题定义为可配置的模式，默认显示如上的文字，之后我们可以在组件外自定义，个性化显示。于是我们调整下wxml的代码。\r\n    <!--遍历星期-->\r\n    <view class='calendar-week'>\r\n        <view wx:for='{{weekText}}' class='item' wx:key='{{item}}'>{{item}}</view>\r\n    </view>\r\n复制代码这样我们就能看到我们想要的效果。\r\n\r\n下面我们开始日期的显示，我们先获取当月有几天，这里的核心代码是\r\n\r\nnew Date(year, month, date).getDate();\r\n\r\n\r\n由此我们做如下尝试\r\n\r\n我们如期获得了返回值，而当我们传入日期为0时返回了31为当月的全部天数。\r\n\r\n由于JavaScript中day的范围为1~31中的值，所以当设为0时，会向前 一天，也即表示上个月的最后一天，通过这种方式可以得到每个月份的天数。\r\n\r\n知道了获取当月天数的原理，我们还需要知道当月1号是星期几。\r\n我们使用如下的方法：\r\n\r\nnew Date(Date.UTC(year, month-1, date)).getDay();\r\n\r\n\r\n我们同样在控制台做出调试；\r\n\r\n需要注意的是，上面的month是实际的月份，而下面这个方法需要在实际的月份上减去1。\r\n于是我们获取0-6之间的值，分别对应周日~周六。\r\n值为6是周六，值为0是周日。\r\n由于日历的第一天是周日，周日对应的是0，于是传入每月1日，返回值为多少，就是星期几，也就说明当月1日前面空几格。\r\n知道了当月就几天，当月前面有几天，我们做一下算法就可以得出，当月后面有几天，于是我们建立如下函数：\r\n    // 组件的初始数据\r\n    data: {\r\n        //当月格子\r\n        thisMonthDays: [],\r\n        //上月格子\r\n        empytGridsBefore: [],\r\n        //下月格子\r\n        empytGridsAfter: [],\r\n},\r\n\r\nmethods: {\r\n        //获取当月天数\r\n        getThisMonthDays: function (year, month) {\r\n            return new Date(year, month, 0).getDate();\r\n        },\r\n        // 绘制当月天数占的格子\r\n        createDays: function (year, month) {\r\n            let thisMonthDays = [],\r\n                days = this.getThisMonthDays(year, month);\r\n            for (let i = 1; i <= days; i++) {\r\n                thisMonthDays.push({\r\n                    date: i,\r\n                    dateFormat: this.zero(i),\r\n                    monthFormat: this.zero(month),\r\n                    week: this.data.weekText[new Date(Date.UTC(year, month - 1, i)).getDay()]\r\n                });\r\n            }\r\n            this.setData({\r\n                thisMonthDays\r\n            })\r\n        },\r\n        //获取当月空出的天数\r\n        createEmptyGrids: function (year, month) {\r\n            let week = new Date(Date.UTC(year, month - 1, 1)).getDay(),\r\n                empytGridsBefore = [],\r\n                empytGridsAfter = [],\r\n                emptyDays = (week == 0 ? 7 : week);\r\n            //当月天数\r\n            var thisMonthDays = this.getThisMonthDays(year, month);\r\n            //上月天数\r\n            var preMonthDays = month - 1 < 0 \r\n                ? this.getThisMonthDays(year - 1, 12) \r\n                : this.getThisMonthDays(year, month - 1);\r\n\r\n            //空出日期\r\n            for (let i = 1; i <= emptyDays; i++) {\r\n                empytGridsBefore.push(preMonthDays - (emptyDays - i));\r\n            }\r\n\r\n            var after = (42 - thisMonthDays - emptyDays) - 7 >= 0 \r\n                        ? (42 - thisMonthDays - emptyDays) - 7 \r\n                        : (42 - thisMonthDays - emptyDays);\r\n            for (let i = 1; i <= after; i++) {\r\n                empytGridsAfter.push(i);\r\n            }\r\n            this.setData({\r\n                empytGridsAfter,\r\n                empytGridsBefore\r\n            })\r\n        },\r\n\r\n        //补全0\r\n        zero: function (i) {\r\n            return i >= 10 ? i : '0' + i;\r\n        },\r\n}\r\n复制代码我们同样修改下wxml代码，同时我们为上月，下月，今天，三个按钮添加相关事件监听。\r\n    <!--显示当前年月日-->\r\n    <view class='calendar-title'>\r\n        <view class='item ctrl' bindtap='lastMonth'>{{lastMonth}}</view>\r\n        <view class='item title'>{{title}}</view>\r\n        <view class='item ctrl' bindtap='nextMonth'>{{nextMonth}}</view>\r\n        <view class='item ctrl today' bindtap='today'>今天</view>\r\n    </view>\r\n复制代码<!--上个月占位格子-->\r\n<view class='grid gray' wx:for='{{empytGridsBefore}}' wx:key='{{item}}'>{{item}}</view>\r\n\r\n<!--当月格子-->\r\n<view class='grid' wx:for='{{thisMonthDays}}' wx:key='{{indx}}'>\r\n   <view class='self' wx:if=\"{{ format === year+'-'+item.monthFormat+'-'+item.dateFormat }}\"></view>\r\n   <view class=\"wrap {{ select === year+'-'+item.monthFormat+'-'+item.dateFormat ? 'select' :''}}\" bindtap='select' data-date='{{item.date}}'>{{item.date}}</view>\r\n</view>\r\n\r\n<!--下个月占位格子-->\r\n<view class='grid gray' wx:for='{{empytGridsAfter}}' wx:key='{{item}}'>{{item}}</view>\r\n复制代码相关的事件监听：\r\n//默认选中当天 并初始化组件\r\ntoday: function () {\r\n    let DATE = this.data.defaultValue ? new Date(this.data.defaultValue) : new Date(),\r\n        year = DATE.getFullYear(),\r\n        month = DATE.getMonth() + 1,\r\n        date = DATE.getDate(),\r\n        select = year + '-' + this.zero(month) + '-' + this.zero(date);\r\n\r\n    this.setData({\r\n        format: select,\r\n        select: select,\r\n        year: year,\r\n        month: month,\r\n        date: date,\r\n        YEAR: year,\r\n        MONTH: month,\r\n        DATE: date,\r\n    })\r\n\r\n    //初始化日历组件UI\r\n    this.display(year, month, date);\r\n\r\n    //发送事件监听\r\n    this.triggerEvent('select', select);\r\n},\r\n//上个月\r\nlastMonth: function () {\r\n    let month = this.data.month == 1 ? 12 : this.data.month - 1;\r\n    let year = this.data.month == 1 ? this.data.year - 1 : this.data.year;\r\n    //初始化日历组件UI\r\n    this.display(year, month, 0);\r\n},\r\n//下个月\r\nnextMonth: function () {\r\n    let month = this.data.month == 12 ? 1 : this.data.month + 1;\r\n    let year = this.data.month == 12 ? this.data.year + 1 : this.data.year;\r\n    //初始化日历组件UI\r\n    this.display(year, month, 0);\r\n},\r\n复制代码代码中我们使用this.display(year, month, 0)为组件统一初始化；\r\n同时在today函数中我们添加事件监听函数，将选中的日期发送到页面，我们通过事件订阅来获取的相关值。\r\n<Calendar id=\"Calendar\" bind:select=\"select\"></Calendar>\r\n复制代码//组件监听事件\r\nselect(e) {\r\n    this.setData({\r\n        selectVal:e.detail\r\n    })\r\n},\r\n复制代码最后我们为切换显示效果的按钮添加事件：\r\n    toggleType(){\r\n        this.selectComponent('#Calendar').toggleType();\r\n    }\r\n复制代码组件中对应的方法，每当切换展示效果，组件都需要初始化\r\n        //切换展示\r\n        toggleType(){\r\n            this.setData({\r\n                toggleType: this.data.toggleType == 'mini' ? 'large' :'mini'\r\n            })\r\n            //初始化日历组件UI\r\n            this.display(this.data.year, this.data.month, this.data.date);\r\n        },\r\n复制代码以上基本上是小程序日历组件实现的基本逻辑，介于篇幅太长还有很多实现上的细节不在此一一细说，大家可以移步我的github\r\n\r\n微信小程序日历组件\r\ngithub.com/749264345/w…\r\n\r\n上文中有不足之处，请给出建议或更优的实现方案，谢谢~\r\n最后祝大家五一快乐~~"}
{"title": "微信小程序---支付密码的输入框 ", "author": "Rolan", "pub_time": "2019-5-6 00:51", "content": "效果如下：干货：<view class=\"pay\"><view class=\"title\">支付方式</view><view catchtap=\"wx_pay\" class=\"wx_pay\"><i class=\"icon {{payment_mode==1?'active':''}}\" type=\"String\"></i><text>微信支付</text></view><view catchtap=\"offline_pay\" class=\"offline_pay\"><i class=\"icon {{payment_mode==0?'active':''}}\" type=\"String\"></i><text>对公打款</text></view><block wx:if=\"{{balance!=0}}\"><view catchtap=\"wallet_pay\" class=\"wallet_pay\"><i class=\"icon {{payment_mode==2?'active':''}}\" type=\"String\"></i><text>钱包支付(余额:{{balance/100}}元)</text></view></block><block wx:if=\"{{balance==0}}\"><view class=\"wallet_pay\"><i class=\"icon\" type=\"String\" style=\"background:#e8e8e8;border:none;\"></i><text style=\"color:#999\">钱包支付(余额不足)</text></view></block></view><view catchtap=\"pay\" class=\"save\">确定</view><!--输入钱包密码--><view wx:if=\"{{wallets_password_flag}}\" class=\"wallets-password\"><view class=\"input-content-wrap\"><view class=\"top\"><view catchtap=\"close_wallets_password\" class=\"close\">×</view><view class=\"txt\">请输入支付密码</view><view catchtap=\"modify_password\" class=\"forget\">忘记密码</view></view><view class=\"actual_fee\"><span>￥</span><text>{{actual_fee/100}}</text></view><view catchtap=\"set_Focus\" class=\"input-password-wrap\"><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=1}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=2}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=3}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=4}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=5}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=6}}\"></i></view></view></view><input bindinput=\"set_wallets_password\" class=\"input-content\" password type=\"number\" focus=\"{{isFocus}}\" maxlength=\"6\" /></view>//index.jsPage({  data: {    payment_mode: 1,//默认支付方式 微信支付    isFocus: false,//控制input 聚焦    balance:100,//余额    actual_fee:20,//待支付    wallets_password_flag:false//密码输入遮罩  },  //事件处理函数  onLoad: function () {  },  wx_pay() {//转换为微信支付    this.setData({      payment_mode: 1    })  },  offline_pay() {//转换为转账支付    this.setData({      payment_mode: 0    })  },  wallet_pay() {    this.setData({//转换为钱包支付      payment_mode: 2    })  },  set_wallets_password(e) {//获取钱包密码    this.setData({      wallets_password: e.detail.value    });    if (this.data.wallets_password.length == 6) {//密码长度6位时，自动验证钱包支付结果      wallet_pay(this)    }  },  set_Focus() {//聚焦input    console.log('isFocus', this.data.isFocus)    this.setData({      isFocus: true    })  },  set_notFocus() {//失去焦点    this.setData({      isFocus: false    })  },  close_wallets_password () {//关闭钱包输入密码遮罩    this.setData({      isFocus: false,//失去焦点      wallets_password_flag: false,    })  },  pay() {//去支付    pay(this)  }})/*-----------------------------------------------*//*支付*/function pay(_this) {  let apikey = _this.data.apikey;  let id = _this.data.id;  let payment_mode = _this.data.payment_mode  if (payment_mode == 1) {  //  微信支付  // 微信自带密码输入框    console.log('微信支付')  } else if (payment_mode == 0) {  //  转账支付 后续跳转至传转账单照片    console.log('转账支付')  } else if (payment_mode == 2) {    // 钱包支付 输入密码    console.log('钱包支付')    _this.setData({      wallets_password_flag: true,      isFocus: true    })  }}// 钱包支付function wallet_pay(_this) {  console.log('钱包支付请求函数')  /*  1.支付成功  2.支付失败：提示；清空密码；自动聚焦isFocus:true，拉起键盘再次输入  */}index.wxsspage {  height: 100%;  width: 100%;  background: #e8e8e8;}page .pay {  display: flex;  flex-direction: column;  background: #fff;}page .pay .title {  height: 90rpx;  line-height: 90rpx;  font-size: 28rpx;  color: #353535;  padding: 0 23rpx;  border-bottom: 1rpx solid #ddd;  box-sizing: border-box;}page .pay .wx_pay, page .pay .offline_pay, page .pay .wallet_pay {  margin: 0 26rpx;  height: 90rpx;  line-height: 90rpx;  border-bottom: 2rpx solid #ddd;  box-sizing: border-box;  display: flex;  align-items: center;  justify-content: flex-start;}page .pay .wx_pay .icon, page .pay .offline_pay .icon,page .pay .wallet_pay .icon {  width: 34rpx;  height: 34rpx;  border: 2rpx solid #ddd;  box-sizing: border-box;  border-radius: 50%;}page .pay .wx_pay .icon.active, page .pay .offline_pay .icon.active,page .pay .wallet_pay .icon.active {  border: 10rpx solid #00a2ff;}page .pay .wx_pay text, page .pay .offline_pay text, page .pay .wallet_pay text {  margin-left: 20rpx;  color: #353535;  font-size: 26rpx;}page .pay .wallet_pay {  border: 0;  border-top: 2rpx solid #ddd;}page .pay .offline_pay {  border: 0 none;}page .save {  margin: 80rpx 23rpx;  color: #fff;  background: #00a2ff;  height: 88rpx;  line-height: 88rpx;  text-align: center;  font-size: 30rpx;  border-radius: 10rpx;}page .wallets-password {  position: absolute;  left: 0;  top: 0;  width: 100%;  height: 100%;  background: rgba(0, 0, 0, 0.6);}page .wallets-password .input-content-wrap {  position: absolute;  top: 200rpx;  left: 50%;  display: flex;  flex-direction: column;  width: 600rpx;  margin-left: -300rpx;  background: #fff;  border-radius: 20rpx;}page .wallets-password .input-content-wrap .top {  display: flex;  align-items: center;  height: 90rpx;  border-bottom: 2rpx solid #ddd;  justify-content: space-around;}page .wallets-password .input-content-wrap .top .close {  font-size: 44rpx;  color: #999;  font-weight: 100;}page .wallets-password .input-content-wrap .top .forget {  color: #00a2ff;  font-size: 22rpx;}page .wallets-password .input-content-wrap .actual_fee {  display: flex;  align-items: center;  justify-content: center;  color: #000;  height: 100rpx;  margin: 0 23rpx;  border-bottom: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .actual_fee span {  font-size: 24rpx;}page .wallets-password .input-content-wrap .actual_fee text {  font-size: 36rpx;}page .wallets-password .input-content-wrap .input-password-wrap {  display: flex;  align-items: center;  justify-content: center;  height: 150rpx;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot {  display: flex;  align-items: center;  justify-content: center;  text-align: center;  color: #000;  box-sizing: border-box;  width: 90rpx;  height: 90rpx;  border: 2rpx solid #ddd;  border-left: none 0;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot:nth-child(1) {  border-left: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot i {  background: #000;  border-radius: 50%;  width: 20rpx;  height: 20rpx;}page .wallets-password .input-content {  position: absolute;  opacity: 0;  left: -100%;  top: 600rpx;  background: #f56;  z-index: -999;}page .wallets-password .input-content.active {  z-index: -99;}github地址：-\">https://github.com/fiveTree/--"}
{"title": "微信小程序全屏模式（自定义导航栏） ", "author": "Rolan", "pub_time": "2019-5-6 00:53", "content": "导航栏背景图要自定义导航栏，首先需要在app.json里设置：{\"window\": {        \"navigationStyle\": \"custom\"    }}设置之后进入小程序就只剩下右上角的胶囊了。 在设置导航栏样式时需要知道它的高度，在app.json的onLaunch里获取状态栏高度：App({    onLaunch: function(options) {        wx.getSystemInfo({            success: (res) => {                this.globalData.statusBarHeight = res.statusBarHeight                this.globalData.navBarHeight = 44 + res.statusBarHeight            }        })    },    globalData: {        statusBarHeight: 0,        screenHeight: 0    }})44是导航栏除去状态栏的高度，单位px。 因为导航栏每个页面都会用到，所以我们用组件会方便使用一些，这里创建一个叫nav的组件： 首先在组件js里设置statusBarHeight和一个可以通过外部设置状态栏颜色的backgroundColor的属性，默认透明。 nav.js:const app = getApp()Component({    options: {        multipleSlots: true    },    properties: {        backgroundColor:{            type: String,            value: 'rgba(0,0,0,0)'        }    },    data: {},    ready() {        let {            statusBarHeight,            navBarHeight        } = app.globalData;        this.setData({            statusBarHeight,            navBarHeight        })    },    methods: {        back() {            wx.navigateBack({                delta:1            })        }    }})content里放置内容，返回按钮固定在左边。 nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <slot name=\"content\"></slot>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:.nav-wrap {    position: fixed;    top: 0;    left: 0;    width: 750rpx;    z-index: 1;}.content {    position: relative;    width: 100%;    height: 44px;}.back {    position: absolute;    left: 0;    top: 0;    width: 88px;    height: 44px;    background: pink;}在页面中使用：<nav bgColor=\"black\">    <view slot=\"content\">        <view class='txt'>Nav title</view>    </view></nav><view>page content</view>效果图：效果图这里txt里的样式、内容都是可以自定义的，如果想要使用通用样式，可以写在组件里。 比如把导航栏title放在组件里，通过外部传值设置： nav.js:Component({    // ...    properties: {        title:{            type: String,            value: ''        }    },    // ...})nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:/* ... */.title {    color: white;    text-align: center;    line-height: 44px;    font-weight: 500;}/* ... */调用就可以了。 在第一次使用nav组件的页面代码中，page content是看不见的，因为是直接从状态栏开始显示的，被nav挡住了。 这里可以加一个高度为导航栏高度的view当做顶部padding： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>这里在properties里设置了一个hastop，用来控制是否有顶部padding。 页面中：<nav bgColor=\"black\" title=\"Nav title\" hastop></nav><view>page content</view>这样就可以显示出来了：导航栏背景图 还可以做导航栏背景图，添加一个image，绝对定位放置在nav-wrap底部： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <image class='bgimg' wx:if=\"{{bgsrc}}\" src='{{bgsrc}}' mode='aspectFill'></image>    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class='title'>{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>nav.wxss.bgimg {    position: absolute;    left: 0;    top: 0;    width: 100%;    height: 100%;}页面：<nav bgColor=\"black\" title=\"Nav title\" hastop bgsrc=\"/images/bg.jpeg\"></nav><view>page content</view>导航栏背景图全屏背景 将bgColor、hastop、bgsrc都去掉，在页面中放置一个position: fixed;，并且铺满全屏的图片。<nav title=\"Nav title\"></nav><image class='pagebg' src='/images/bg.jpeg' mode='aspectFill'></image>全屏背景back的内容自定义就行了，我这里只是简单放置了一个色框。注意事项 官方文档中的注意事项：注1：HexColor（十六进制颜色值），如\"#ff00ff\" 注2：关于navigationStyle客户端 7.0.0 以下版本，navigationStyle 只在 app.json 中生效。 客户端 6.7.2 版本开始，navigationStyle: custom 对 组件无效 开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用）可方便切到旧视觉"}
